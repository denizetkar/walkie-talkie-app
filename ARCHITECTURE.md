# ðŸ—ï¸ Architecture & Protocol Design

This document details the internal logic, network topology, and security protocols of the Bluetooth LE Mesh Walkie-Talkie.

---

## 1. Network Topology: Symmetric Mesh with Convergence

Unlike traditional "Host/Client" models, this app uses a **Symmetric Peer-to-Peer Mesh** that automatically converges to a single logical network to prevent "Island" formation.

### The "Network ID" Convergence Strategy
To ensure all devices form a single contiguous mesh, we use a **Root-Based Hierarchy** for topology control (though data routing remains peer-to-peer).
*   **Node ID:** A random 4-byte integer generated by every node on startup.
*   **Network ID:** The Node ID of the "Root" (the device with the numerically highest Node ID in the cluster).
*   **Convergence:** Nodes always prefer connecting to peers advertising a *higher* Network ID.
*   **Heartbeat:** The Root emits a periodic heartbeat (~1s). If a node stops receiving this heartbeat (~3s), it assumes the Root is gone, reverts to its own ID, and restarts the convergence process.

### The "Target vs. Max" Strategy
To balance battery life with connectivity, each node follows this connection logic:

| Parameter | Value | Description |
| :--- | :--- | :--- |
| **Target Peers** | **3** | The "Stable" state. If a node has 3 neighbors, it slows down scanning to save battery. |
| **Max Peers** | **5** | The "Burst" capacity. Nodes keep 2 slots open specifically to accept connections from strangers (merging islands). |

---

## 2. Discovery Protocol (Split-Packet Advertising)

We utilize **Legacy Advertising** (31 bytes) to ensure compatibility. We split discovery data into two packets: one for machine logic (Topology) and one for human info (Group Name).

### Packet A: The Logic (Advertising Packet)
Broadcast constantly via **Service Data**. Used to filter nodes and detect "Better Networks" (Islands) before connecting.

**Service Data Layout (10 bytes + Header):**
| Byte Offset | Field | Description |
| :--- | :--- | :--- |
| `[0-3]` | **Node ID** | My random ID. |
| `[4-7]` | **Network ID** | The ID of the Root I am currently following. |
| `[8]` | **Hops** | Distance to Root (0 if I am Root). |
| `[9]` | **Availability** | Bitmask/Flag. (`1` = Has free slots, `0` = Full). |

### Packet B: The Human Info (Scan Response)
Sent only when a scanner requests more info.
*   **Manufacturer Data (ID: 0xFFFF):**
    *   `[0-N]` **Group Name:** UTF-8 String (Max ~20 bytes).

---

## 3. GATT Protocol: The "Two-Pipe" Architecture

To maximize throughput and simplify the GATT server, we expose only **two characteristics** under the App Service.

### A. The Control Characteristic (Reliable / High Priority)
*   **Properties:** `Write` | `Notify`
*   **Usage:** Handshakes, Heartbeats, Topology Updates.
*   **Priority:** **High**. These packets jump the queue ahead of audio.
*   **Format:** Binary Packet with Header.

**Packet Structure:**
| Byte | Field | Description |
| :--- | :--- | :--- |
| `0` | **Header** | `Version` (4 bits) + `Flags` (4 bits). |
| `1` | **Type** | Message OpCode (see table below). |
| `2-N` | **Payload** | Variable length data based on Type. |

**Control Message Types:**
| Hex | Name | Payload |
| :--- | :--- | :--- |
| `0x04` | **CLIENT_HELLO** | `[Empty]` (Triggers the Challenge) |
| `0x01` | **AUTH_CHALLENGE** | `[Nonce (8 bytes)]` |
| `0x02` | **AUTH_RESPONSE** | `[Hash (12 bytes)] [NodeID (4 bytes)]` |
| `0x03` | **AUTH_RESULT** | `[Result (1 byte: 0=Fail, 1=Success)]` |
| `0x10` | **HEARTBEAT** | `[NetID (4)] [Seq (4)] [Hops (1)]` |
| `0xA0` | **PING** | `[Empty]` |

### B. The Data Characteristic (High Throughput / Low Priority)
*   **Properties:** `Write No Response` | `Notify`
*   **Usage:** Voice Audio (Opus).
*   **Priority:** **Low**. Dropped if queue is full.
*   **Format:** Raw Opus Frames (Wrapped with 2-byte Sequence Number in Rust).

---

## 4. Security: Challenge-Response State Machine

The **Access Code** is treated as a Pre-Shared Key (PSK). Authentication is a state machine executed over the **Control Characteristic**.

### The Handshake Flow
1.  **Connect:** GATT connection established.
2.  **Hello:** Client sends `0x04 (CLIENT_HELLO)`.
3.  **Challenge:** Server sends `0x01 (AUTH_CHALLENGE)` + `Nonce`.
4.  **Calculation:** Client computes `SHA256(AccessCode + Nonce + ClientNodeID)`.
    *   *Truncation:* The hash is truncated to **12 bytes** to fit the packet within standard MTU limits.
5.  **Response:** Client sends `0x02 (AUTH_RESPONSE)` + `[Hash (12 bytes)] [ClientNodeID (4 bytes)]`.
6.  **Verification:** Server extracts Node ID, re-computes hash, and compares.
    *   *Valid:* Server sends `0x03 (AUTH_RESULT)` + `0x01`. Both nodes mark link as `AUTHENTICATED`.
    *   *Invalid:* Server sends `0x03` + `0x00` and disconnects.

---

## 5. Software Layering & Concurrency

### Responsibility Separation (Smart Controller / Dumb Driver)
We adhere to the **End-to-End Principle** for packet handling:
*   **BLE Driver:** Acts as a "Dumb Pipe". It does **not** modify payloads for routing packets (Heartbeats/Audio). It only handles Link-Layer logic (Connection, Auth Handshake).
*   **Mesh Controller:** Owns the "Wire Format". It constructs the full packet (Header + OpCode + Payload) for Heartbeats.
*   **Loop Detection:** The Controller hashes the **entire packet** (Header + OpCode + Payload) to detect duplicates. This ensures that if a packet is modified (e.g., Hops incremented), the hash changes, allowing the packet to propagate correctly.

### "Hot Mic" Audio Architecture
The `VoiceManager` and Rust `AudioEngine` utilize a "Hot Mic" approach:
1.  **Streams Always Open:** When the user joins a group, the Audio Input (Mic) and Output (Speaker) streams are opened immediately.
2.  **Software Gating:** When the user is *not* holding the PTT button, the audio engine processes the microphone buffer to clear it but does **not** encode or transmit.
3.  **Benefit:** This removes the ~300ms delay usually caused by powering up the Android Audio hardware when the button is pressed.

### BLE Operation Queue
To prevent "GATT Busy" errors common in Android:
*   **`BleOperationQueue`:** Serializes all GATT Writes and Descriptor updates.
*   **Starvation Prevention:** The queue logic ensures `CONTROL` packets are prioritized, but forces an `AUDIO` packet through after a sequence of 4 consecutive control packets to prevent audio starvation.

### Scan Rate Limiter
Android 7+ enforces a hard limit of **5 scans per 30 seconds**.
*   **`ScanRateLimiter`:** Tracks scan timestamps. If the quota is full, scan requests are ignored at the software level to prevent system-level exceptions (Error Code 6).

---

## 6. Audio Engine (Rust Implementation)

The Audio Engine interfaces with Android via `oboe` and handles compression using `opus-codec`.

### A. The Interface (UniFFI)
*   **Kotlin -> Rust:** `start_session()`, `stop_session()`, `set_mic_enabled(bool)`, `push_incoming_packet(bytes)`.
*   **Rust -> Kotlin:** `PacketTransport` callback interface for sending encoded data.

### B. Audio Pipeline
1.  **Input (Microphone):**
    *   **Config:** 48kHz, Mono, Low Latency.
    *   **Framing:** **60ms** frame size. This is larger than typical VoIP (20ms) to reduce the packets-per-second load on the BLE stack (approx 16 packets/sec).
2.  **Encoding:**
    *   **Codec:** Opus (VOIP Application).
    *   **Packetization:** `[Node ID (4 bytes)] [Seq Num (2 bytes)] [Opus Data (variable)]`.
3.  **Output (Speaker):**
    *   **Demultiplexing:** The engine reads the `Node ID` to separate streams from different peers.
    *   **Jitter Buffer:** A `BTreeMap<u16, Vec<u8>>` per peer. This sorts incoming packets by Sequence Number automatically.
    *   **Buffering:** The engine buffers ~6 packets (~360ms) before starting playback to ensure smoothness.
    *   **PLC:** If a packet is missing, Opus Packet Loss Concealment is triggered.

---

## 7. Build System & FFI Strategy

Integrating Rust with Android requires handling the C++ Runtime (`libc++_shared.so`).

1.  **Linking:** Cargo is configured to link `-lc++_shared`.
2.  **Packaging:** The `build.ps1` script extracts `libc++_shared.so` from the NDK and places it in `jniLibs/arm64-v8a/`.
3.  **Runtime:** `MainApplication` explicitly loads `c++_shared` before loading the Rust library to ensure symbols are resolved.