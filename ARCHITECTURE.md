# ðŸ—ï¸ Architecture & Protocol Design

This document details the internal logic, network topology, and security protocols of the Bluetooth LE Mesh Walkie-Talkie.

---

## 1. Network Topology: Symmetric Mesh with Convergence

Unlike traditional "Host/Client" models, this app uses a **Symmetric Peer-to-Peer Mesh** that automatically converges to a single logical network to prevent "Island" formation.

### The "Network ID" Convergence Strategy
To ensure all devices form a single contiguous mesh, we use a **Root-Based Hierarchy** for topology control (though data routing remains peer-to-peer).
*   **Node ID:** A random 4-byte integer generated by every node on startup.
*   **Network ID:** The Node ID of the "Root" (the device with the numerically highest Node ID in the cluster).
*   **Convergence:** Nodes always prefer connecting to peers advertising a *higher* Network ID.
*   **Heartbeat:** The Root emits a periodic heartbeat. If a node stops receiving this heartbeat, it assumes the Root is gone, reverts to its own ID, and restarts the convergence process.

### The "Target vs. Max" Strategy
To balance battery life with connectivity, each node follows this connection logic:

| Parameter | Value | Description |
| :--- | :--- | :--- |
| **Target Peers** | **3** | The "Stable" state. If a node has 3 neighbors, it stops aggressive scanning. |
| **Max Peers** | **5** | The "Burst" capacity. Nodes keep 2 slots open specifically to accept connections from strangers (merging islands). |

---

## 2. Discovery Protocol (Split-Packet Advertising)

We utilize **Legacy Advertising** (31 bytes) to ensure compatibility with all Android 9+ devices. We split discovery data into two packets: one for machine logic (Topology) and one for human info (Group Name).

### Packet A: The Logic (Advertising Packet)
Broadcast constantly via **Service Data**. Used to filter nodes and detect "Better Networks" (Islands) before connecting.

**Service Data Layout (10 bytes + Header):**
| Byte Offset | Field | Description |
| :--- | :--- | :--- |
| `[0-3]` | **Node ID** | My random ID. |
| `[4-7]` | **Network ID** | The ID of the Root I am currently following. |
| `[8]` | **Hops** | Distance to Root (0 if I am Root). |
| `[9]` | **Availability** | Bitmask/Flag. (`1` = Has free slots, `0` = Full). |

### Packet B: The Human Info (Scan Response)
Sent only when a scanner requests more info.
*   **Manufacturer Data (ID: 0xFFFF):**
    *   `[0-N]` **Group Name:** UTF-8 String (Max ~24 bytes).

---

## 3. GATT Protocol: The "Two-Pipe" Architecture

To maximize throughput and simplify the GATT server, we expose only **two characteristics** under the App Service.

### A. The Control Characteristic (Reliable / High Priority)
*   **Properties:** `Write` (or Write No Response) | `Notify`
*   **Usage:** Handshakes, Heartbeats, Topology Updates.
*   **Priority:** **High (0)**. These packets jump the queue ahead of audio.
*   **Format:** Binary Packet with Header.

**Packet Structure:**
| Byte | Field | Description |
| :--- | :--- | :--- |
| `0` | **Header** | `Version` (4 bits) + `Flags` (4 bits). |
| `1` | **Type** | Message OpCode (see table below). |
| `2-N` | **Payload** | Variable length data based on Type. |

**Control Message Types:**
| Hex | Name | Payload |
| :--- | :--- | :--- |
| `0x01` | **AUTH_CHALLENGE** | `[Nonce (8 bytes)]` |
| `0x02` | **AUTH_RESPONSE** | `[Hash (16 bytes)] [NodeID (4 bytes)]` |
| `0x03` | **AUTH_RESULT** | `[Result (1 byte: 0=Fail, 1=Success)]` |
| `0x10` | **HEARTBEAT** | `[NetID (4)] [Seq (4)] [Hops (1)]` |

### B. The Data Characteristic (High Throughput / Low Priority)
*   **Properties:** `Write No Response` | `Notify`
*   **Usage:** Voice Audio (Opus).
*   **Priority:** **Low (1)**. Dropped if queue is full.
*   **Format:** Raw Opus Frames (or wrapped with minimal header).

---

## 4. Security: Challenge-Response State Machine

The **Access Code** is treated as a Pre-Shared Key (PSK). Authentication is a state machine executed over the **Control Characteristic**. To prevent Replay Attacks, the Node ID is bound to the hash.

### The Handshake Flow
1.  **Connect:** GATT connection established.
2.  **Challenge:** Server sends `0x01 (AUTH_CHALLENGE)` + `Nonce`.
3.  **Calculation:** Client computes `SHA256(AccessCode + Nonce + ClientNodeID)`.
4.  **Response:** Client sends `0x02 (AUTH_RESPONSE)` + `[Hash (16 bytes)] [ClientNodeID (4 bytes)]`.
5.  **Verification:** Server extracts Node ID, re-computes hash, and compares.
    *   *Valid:* Server sends `0x03 (AUTH_RESULT)` + `0x01`. Both nodes mark link as `AUTHENTICATED`.
    *   *Invalid:* Server sends `0x03` + `0x00` and disconnects.
6.  **Sync:** Immediately upon authentication, both nodes exchange `0x10 (HEARTBEAT)` to sync Topology state.

---

## 5. Software Layering

The app follows a Clean Architecture approach with Reactive State management.

### Layer 1: The Brain (`logic/`)
*   **`MeshNetworkManager`:**
    *   **Reactive State:** Observes `Transport.connectedPeers` as the Single Source of Truth.
    *   **Topology State:** Tracks `CurrentNetworkID`, `HopsToRoot`, and `LastHeartbeatTime`.
    *   **Heartbeat Loop:** Root generates heartbeats (~1s). Followers check for timeouts (~3s) to detect Root loss.
    *   **Peer Selection Strategy:**
        1.  **Island Merge:** Priority connect if `Remote.NetID > Local.NetID`.
        2.  **Fill Slots:** Connect if `Peers < Target (3)`.
        3.  **Absorb:** Connect if `Peers < Max (5)` and `Remote.NetID < Local.NetID`.
    *   **Race Condition Handling:** Maintains a `pendingConnections` set to prevent duplicate connection attempts.

### Layer 2: The Abstraction (`network/`)
*   **`NetworkTransport`:**
    *   Exposes `connectedPeers` (StateFlow) and `events` (SharedFlow).
    *   Abstracts the specific packet formats.

### Layer 3: The Hardware (`bluetooth/`)
*   **`BleTransport`:**
    *   **Reactive Map:** Maintains `MutableStateFlow<Map<Int, BlePeer>>`.
    *   **Priority Queue:** Uses a `PriorityBlockingQueue` to ensure Control packets are sent before Audio packets.
    *   **MTU Tracking:** Negotiates MTU per client, though currently defaults to safe limits.

---

## 6. Data Flow (Flooding & Routing)

### Voice/Chat (Flooding)
1.  **Source:** User speaks. Audio encoded to Opus (via Rust).
2.  **Packet:** Wrapped in `0x50` (Voice) Data Packet.
3.  **Relay:**
    *   Received on `DATA` characteristic.
    *   **Deduplication:** Kotlin checks `seenPackets` cache.
    *   If new:
        1.  Send to Rust Engine (Decoding/Playback).
        2.  Forward to all other `AUTHENTICATED` peers (Flooding).

### Topology (Controlled Propagation)
1.  **Source:** Root Node generates `HEARTBEAT` (Control `0x10`).
2.  **Relay:**
    *   Node receives Heartbeat.
    *   **Check:** Is `Seq > StoredSeq`?
    *   **If Yes:** Update local state (`Hops = RxHops + 1`), then Forward to all peers.
    *   **If No:** Discard.

---

## 7. Audio Engine (Rust Implementation)

The Audio Engine is written in **Rust** to ensure memory safety and low latency. It interfaces with Android's Audio API via the `oboe` crate and handles compression using `opus-codec`.

### A. The Interface (UniFFI)
We use **UniFFI** to generate the Kotlin bindings. The interface is defined in Rust and exposed as a Kotlin class `AudioEngine`.

*   **Kotlin -> Rust:**
    *   `start_recording()`: Opens the Input Stream (Microphone).
    *   `stop_recording()`: Closes the Input Stream.
    *   `push_incoming_packet(data: ByteArray)`: Pushes received BLE data into the Jitter Buffer.
*   **Rust -> Kotlin (Callback):**
    *   `PacketTransport` trait: A callback interface implemented in Kotlin.
    *   When Rust encodes a frame, it calls `transport.send_packet(data)`, which triggers the BLE flood in Kotlin.

### B. Audio Pipeline
1.  **Input (Microphone):**
    *   **API:** Oboe (AAudio)
    *   **Config:** 48kHz, Mono, Low Latency, Exclusive Mode.
    *   **Buffering:** Raw PCM samples are collected until we have 20ms worth of audio (960 samples).
2.  **Encoding:**
    *   **Codec:** Opus (VOIP Application).
    *   **Bitrate:** Variable (VBR).
    *   **Packetization:** The Opus frame is wrapped with a 2-byte **Sequence Number** (for ordering/jitter handling) before being sent to Kotlin.
3.  **Output (Speaker):**
    *   **API:** Oboe (Audio)
    *   **Jitter Buffer:** A `VecDeque` (Double-ended queue) stores incoming Opus packets.
    *   **Decoding:** The callback pulls from the queue, decodes via Opus, and fills the audio buffer. If the queue is empty (underrun), it generates silence (PLC).

### C. Jitter Buffer Strategy
Since BLE delivery is not guaranteed to be in order or perfectly timed, we use a **Fixed-Size De-Jitter Queue**.
*   **Logic:** Incoming packets are pushed to the back of the queue.
*   **Playback:** The audio thread pops from the front.
*   **Overflow Protection:** If the queue exceeds 50 packets (~1 second), the oldest packets are dropped to reduce latency.

---

## 8. Build System & FFI Strategy

Integrating Rust with Android requires a specific build pipeline to handle the C++ Runtime (`libc++_shared.so`) required by Oboe.

### The "Shared Runtime" Challenge
Android's Oboe library is C++ code. When Rust links against it, it expects the C++ symbols to be available at runtime.
1.  **Linking:** We configure Cargo (`.cargo/config.toml`) to link with `-lc++_shared`.
2.  **Packaging:** The Gradle build script (`build.ps1`) manually locates `libc++_shared.so` inside the Android NDK and copies it to `src/main/jniLibs/arm64-v8a/`.
3.  **Loading:** In `MainActivity.kt`, we explicitly load `libc++_shared` before loading the Rust library.

### The Build Chain
1.  **Gradle Sync:** Triggers `build.ps1`.
2.  **Cargo NDK:** Compiles Rust code to `.so`.
3.  **UniFFI Bindgen:** Generates `walkie_talkie_engine.kt` from the compiled library.
4.  **APK Package:** Bundles the Rust `.so`, the `libc++_shared.so`, and the JNA/UniFFI generated code.