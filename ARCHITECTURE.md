# ðŸ—ï¸ Architecture & Protocol Design

This document details the internal logic, network topology, and security protocols of the Bluetooth LE Mesh Walkie-Talkie.

---

## 1. Network Topology: Symmetric Mesh with Convergence

Unlike traditional "Host/Client" models, this app uses a **Symmetric Peer-to-Peer Mesh** that automatically converges to a single logical network to prevent "Island" formation.

### The "Network ID" Convergence Strategy
To ensure all devices form a single contiguous mesh, we use a **Root-Based Hierarchy** for topology control (though data routing remains peer-to-peer).
*   **Node ID:** A random 4-byte integer generated by every node on startup.
*   **Network ID:** The Node ID of the "Root" (the device with the numerically highest Node ID in the cluster).
*   **Convergence:** Nodes always prefer connecting to peers advertising a *higher* Network ID.
*   **Heartbeat:** The Root emits a periodic heartbeat. If a node stops receiving this heartbeat, it assumes the Root is gone, reverts to its own ID, and restarts the convergence process.

### The "Target vs. Max" Strategy
To balance battery life with connectivity, each node follows this connection logic:

| Parameter | Value | Description |
| :--- | :--- | :--- |
| **Target Peers** | **3** | The "Stable" state. If a node has 3 neighbors, it stops aggressive scanning. |
| **Max Peers** | **5** | The "Burst" capacity. Nodes keep 2 slots open specifically to accept connections from strangers (merging islands). |

---

## 2. Discovery Protocol (Split-Packet Advertising)

We utilize **Legacy Advertising** (31 bytes) to ensure compatibility with all Android 9+ devices. We split discovery data into two packets: one for machine logic (Topology) and one for human info (Group Name).

### Packet A: The Logic (Advertising Packet)
Broadcast constantly via **Service Data**. Used to filter nodes and detect "Better Networks" (Islands) before connecting.

**Service Data Layout (10 bytes + Header):**
| Byte Offset | Field | Description |
| :--- | :--- | :--- |
| `[0-3]` | **Node ID** | My random ID. |
| `[4-7]` | **Network ID** | The ID of the Root I am currently following. |
| `[8]` | **Hops** | Distance to Root (0 if I am Root). |
| `[9]` | **Availability** | Bitmask/Flag. (`1` = Has free slots, `0` = Full). |

### Packet B: The Human Info (Scan Response)
Sent only when a scanner requests more info.
*   **Manufacturer Data (ID: 0xFFFF):**
    *   `[0-N]` **Group Name:** UTF-8 String (Max ~24 bytes).

---

## 3. GATT Protocol: The "Two-Pipe" Architecture

To maximize the negotiated **512-byte MTU** and simplify the GATT server, we expose only **two characteristics** under the App Service.

### A. The Control Characteristic (Reliable)
*   **Properties:** `Write` (or Write No Response) | `Notify`
*   **Usage:** Handshakes, Heartbeats, Topology Updates.
*   **Format:** Binary Packet with Header.

**Packet Structure:**
| Byte | Field | Description |
| :--- | :--- | :--- |
| `0` | **Header** | `Version` (4 bits) + `Flags` (4 bits). |
| `1` | **Type** | Message OpCode (see table below). |
| `2-N` | **Payload** | Variable length data based on Type. |

**Control Message Types:**
| Hex | Name | Payload |
| :--- | :--- | :--- |
| `0x01` | **AUTH_CHALLENGE** | `[Nonce (8 bytes)]` |
| `0x02` | **AUTH_RESPONSE** | `[Hash (16 bytes)]` |
| `0x03` | **AUTH_RESULT** | `[Result (1 byte: 0=Fail, 1=Success)]` |
| `0x10` | **HEARTBEAT** | `[NetID (4)] [Seq (4)] [Hops (1)]` |

### B. The Data Characteristic (High Throughput)
*   **Properties:** `Write No Response` | `Notify`
*   **Usage:** Voice Audio (Opus), File Chunks.
*   **Format:** Minimal Header to maximize payload.
*   **Structure:** `[Type (1 byte)] [Raw Data...]` (e.g., `0x50` for Opus Audio).

---

## 4. Security: Challenge-Response State Machine

The **Access Code** is treated as a Pre-Shared Key (PSK). Authentication is now a state machine executed over the **Control Characteristic**.

### The Handshake Flow
1.  **Connect:** GATT connection established.
2.  **Challenge:** Server sends `0x01 (AUTH_CHALLENGE)` + `Nonce`.
3.  **Calculation:** Client computes `SHA256(AccessCode + Nonce)`.
4.  **Response:** Client sends `0x02 (AUTH_RESPONSE)` + `First 16 bytes of Hash`.
5.  **Verification:** Server verifies hash.
    *   *Valid:* Server sends `0x03 (AUTH_RESULT)` + `0x01`. Both nodes mark link as `AUTHENTICATED`.
    *   *Invalid:* Server sends `0x03` + `0x00` and disconnects.
6.  **Sync:** Immediately upon authentication, both nodes exchange `0x10 (HEARTBEAT)` to sync Topology state.

---

## 5. Software Layering

The app follows a Clean Architecture approach.

### Layer 1: The Brain (`logic/`)
*   **`MeshNetworkManager`:**
    *   **Topology State:** Tracks `CurrentNetworkID`, `HopsToRoot`, and `LastHeartbeatTime`.
    *   **Heartbeat Loop:** If Root, generates heartbeats every 5s. If Follower, checks for timeouts (15s).
    *   **Peer Selection:** Prioritizes scanning/connecting to nodes with `Remote.NetworkID > Local.NetworkID`.

### Layer 2: The Abstraction (`network/`)
*   **`NetworkTransport`:**
    *   Abstracts the specific packet formats.
    *   Exposes `sendControl(type, payload)` and `sendData(type, payload)`.

### Layer 3: The Hardware (`bluetooth/`)
*   **`BleTransport`:**
    *   **`PacketSerializer`:** Handles the packing/unpacking of the Control Header and Message Types.
    *   **`GattHandler`:** Manages the single Service and two Characteristics.

---

## 6. Data Flow (Flooding & Routing)

### Voice/Chat (Flooding)
1.  **Source:** User speaks. Audio encoded to Opus.
2.  **Packet:** Wrapped in `0x50` (Voice) Data Packet.
3.  **Relay:**
    *   Received on `DATA` characteristic.
    *   Deduplicated via Cache (Hash of payload).
    *   If new: Play Audio -> Forward to all other `AUTHENTICATED` peers.

### Topology (Controlled Propagation)
1.  **Source:** Root Node generates `HEARTBEAT` (Control `0x10`).
2.  **Relay:**
    *   Node receives Heartbeat.
    *   **Check:** Is `Seq > StoredSeq`?
    *   **If Yes:** Update local state (`Hops = RxHops + 1`), then Forward to all peers.
    *   **If No:** Discard.