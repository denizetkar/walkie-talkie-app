# ðŸ—ï¸ Architecture & Protocol Design

This document details the internal logic, network topology, and security protocols of the Bluetooth LE Mesh Walkie-Talkie.

---

## 1. Network Topology: Symmetric Mesh with Convergence

Unlike traditional "Host/Client" models, this app uses a **Symmetric Peer-to-Peer Mesh** that automatically converges to a single logical network to prevent "Island" formation.

### The "Network ID" Convergence Strategy
To ensure all devices form a single contiguous mesh, we use a **Root-Based Hierarchy** for topology control (though data routing remains peer-to-peer).
*   **Node ID:** A random 4-byte integer generated by every node on startup.
*   **Network ID:** The Node ID of the "Root" (the device with the numerically highest Node ID in the cluster).
*   **Convergence:** Nodes always prefer connecting to peers advertising a *higher* Network ID.
*   **Heartbeat:** The Root emits a periodic heartbeat. If a node stops receiving this heartbeat, it assumes the Root is gone, reverts to its own ID, and restarts the convergence process.

### The "Target vs. Max" Strategy
To balance battery life with connectivity, each node follows this connection logic:

| Parameter | Value | Description |
| :--- | :--- | :--- |
| **Target Peers** | **3** | The "Stable" state. If a node has 3 neighbors, it stops aggressive scanning. |
| **Max Peers** | **5** | The "Burst" capacity. Nodes keep 2 slots open specifically to accept connections from strangers (merging islands). |

---

## 2. Discovery Protocol (Split-Packet Advertising)

We utilize **Legacy Advertising** (31 bytes) to ensure compatibility with all Android 9+ devices. We split discovery data into two packets: one for machine logic (Topology) and one for human info (Group Name).

### Packet A: The Logic (Advertising Packet)
Broadcast constantly via **Service Data**. Used to filter nodes and detect "Better Networks" (Islands) before connecting.

**Service Data Layout (10 bytes + Header):**
| Byte Offset | Field | Description |
| :--- | :--- | :--- |
| `[0-3]` | **Node ID** | My random ID. |
| `[4-7]` | **Network ID** | The ID of the Root I am currently following. |
| `[8]` | **Hops** | Distance to Root (0 if I am Root). |
| `[9]` | **Availability** | Bitmask/Flag. (`1` = Has free slots, `0` = Full). |

### Packet B: The Human Info (Scan Response)
Sent only when a scanner requests more info.
*   **Manufacturer Data (ID: 0xFFFF):**
    *   `[0-N]` **Group Name:** UTF-8 String (Max ~24 bytes).

---

## 3. GATT Protocol: The "Two-Pipe" Architecture

To maximize throughput and simplify the GATT server, we expose only **two characteristics** under the App Service.

### A. The Control Characteristic (Reliable / High Priority)
*   **Properties:** `Write` (or Write No Response) | `Notify`
*   **Usage:** Handshakes, Heartbeats, Topology Updates.
*   **Priority:** **High (0)**. These packets jump the queue ahead of audio.
*   **Format:** Binary Packet with Header.

**Packet Structure:**
| Byte | Field | Description |
| :--- | :--- | :--- |
| `0` | **Header** | `Version` (4 bits) + `Flags` (4 bits). |
| `1` | **Type** | Message OpCode (see table below). |
| `2-N` | **Payload** | Variable length data based on Type. |

**Control Message Types:**
| Hex | Name | Payload |
| :--- | :--- | :--- |
| `0x01` | **AUTH_CHALLENGE** | `[Nonce (8 bytes)]` |
| `0x02` | **AUTH_RESPONSE** | `[Hash (16 bytes)] [NodeID (4 bytes)]` |
| `0x03` | **AUTH_RESULT** | `[Result (1 byte: 0=Fail, 1=Success)]` |
| `0x10` | **HEARTBEAT** | `[NetID (4)] [Seq (4)] [Hops (1)]` |

### B. The Data Characteristic (High Throughput / Low Priority)
*   **Properties:** `Write No Response` | `Notify`
*   **Usage:** Voice Audio (Opus).
*   **Priority:** **Low (1)**. Dropped if queue is full.
*   **Format:** Raw Opus Frames (or wrapped with minimal header).

---

## 4. Security: Challenge-Response State Machine

The **Access Code** is treated as a Pre-Shared Key (PSK). Authentication is a state machine executed over the **Control Characteristic**. To prevent Replay Attacks, the Node ID is bound to the hash.

### The Handshake Flow
1.  **Connect:** GATT connection established.
2.  **Challenge:** Server sends `0x01 (AUTH_CHALLENGE)` + `Nonce`.
3.  **Calculation:** Client computes `SHA256(AccessCode + Nonce + ClientNodeID)`.
4.  **Response:** Client sends `0x02 (AUTH_RESPONSE)` + `[Hash (16 bytes)] [ClientNodeID (4 bytes)]`.
5.  **Verification:** Server extracts Node ID, re-computes hash, and compares.
    *   *Valid:* Server sends `0x03 (AUTH_RESULT)` + `0x01`. Both nodes mark link as `AUTHENTICATED`.
    *   *Invalid:* Server sends `0x03` + `0x00` and disconnects.
6.  **Sync:** Immediately upon authentication, both nodes exchange `0x10 (HEARTBEAT)` to sync Topology state.

---

## 5. Software Layering

The app follows a Clean Architecture approach with Reactive State management.

### Layer 1: The Brain (`logic/`)
*   **`MeshNetworkManager`:**
    *   **Reactive State:** Observes `Transport.connectedPeers` as the Single Source of Truth.
    *   **Topology State:** Tracks `CurrentNetworkID`, `HopsToRoot`, and `LastHeartbeatTime`.
    *   **Heartbeat Loop:** Root generates heartbeats (~1s). Followers check for timeouts (~3s) to detect Root loss.
    *   **Peer Selection Strategy:**
        1.  **Island Merge:** Priority connect if `Remote.NetID > Local.NetID`.
        2.  **Fill Slots:** Connect if `Peers < Target (3)`.
        3.  **Absorb:** Connect if `Peers < Max (5)` and `Remote.NetID < Local.NetID`.
    *   **Race Condition Handling:** Maintains a `pendingConnections` set to prevent duplicate connection attempts.

### Layer 2: The Abstraction (`network/`)
*   **`NetworkTransport`:**
    *   Exposes `connectedPeers` (StateFlow) and `events` (SharedFlow).
    *   Abstracts the specific packet formats.

### Layer 3: The Hardware (`bluetooth/`)
*   **`BleTransport`:**
    *   **Reactive Map:** Maintains `MutableStateFlow<Map<Int, BlePeer>>`.
    *   **Priority Queue:** Uses a `PriorityBlockingQueue` to ensure Control packets are sent before Audio packets.
    *   **MTU Tracking:** Negotiates MTU per client, though currently defaults to safe limits.

---

## 6. Data Flow (Flooding & Routing)

### Voice/Chat (Flooding)
1.  **Source:** User speaks. Audio encoded to Opus (via Rust).
2.  **Packet:** Wrapped in `0x50` (Voice) Data Packet.
3.  **Relay:**
    *   Received on `DATA` characteristic.
    *   **Deduplication:** Kotlin checks `seenPackets` cache.
    *   If new:
        1.  Send to Rust Engine (Decoding/Playback).
        2.  Forward to all other `AUTHENTICATED` peers (Flooding).

### Topology (Controlled Propagation)
1.  **Source:** Root Node generates `HEARTBEAT` (Control `0x10`).
2.  **Relay:**
    *   Node receives Heartbeat.
    *   **Check:** Is `Seq > StoredSeq`?
    *   **If Yes:** Update local state (`Hops = RxHops + 1`), then Forward to all peers.
    *   **If No:** Discard.

---

## 7. Audio Engine & Rust Interface Constraints

The Rust library (`rust/`) is responsible for Audio I/O, Encoding, and Jitter Buffering. It must adhere to the constraints imposed by the BLE Transport.

### A. MTU Awareness
*   **Constraint:** BLE MTU varies per device (23 to 512 bytes).
*   **Requirement:** The Rust Encoder must accept a `max_packet_size` parameter.
*   **Strategy:** If the negotiated MTU is small (e.g., 23 bytes), Rust must either:
    *   Increase Opus compression (lower bitrate).
    *   Or fragment packets (though this increases latency/complexity).
    *   *Current Decision:* Target ~40-60 byte Opus frames to fit in standard BLE packets without fragmentation.

### B. Jitter Buffer
*   **Constraint:** BLE is lossy and jittery. Packets arrive out of order.
*   **Requirement:** Rust must implement a Jitter Buffer (e.g., 60ms - 100ms) to smooth out playback.

### C. Interface Boundary (Kotlin <-> Rust)
*   **Kotlin -> Rust:**
    *   `init_audio(sample_rate: i32, channels: i32)`
    *   `push_incoming_packet(data: &[u8])` (Called when BLE receives data)
    *   `start_recording()` / `stop_recording()`
*   **Rust -> Kotlin:**
    *   `on_packet_generated(data: &[u8])` (Callback: Rust gives Kotlin a packet to flood via BLE).